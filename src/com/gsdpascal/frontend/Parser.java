//### This file created by BYACC 1.8(/Java extension  1.15)
//### Java capabilities added 7 Jan 97, Bob Jamison
//### Updated : 27 Nov 97  -- Bob Jamison, Joe Nieten
//###           01 Jan 98  -- Bob Jamison -- fixed generic semantic constructor
//###           01 Jun 99  -- Bob Jamison -- added Runnable support
//###           06 Aug 00  -- Bob Jamison -- made state variables class-global
//###           03 Jan 01  -- Bob Jamison -- improved flags, tracing
//###           16 May 01  -- Bob Jamison -- added custom stack sizing
//###           04 Mar 02  -- Yuval Oren  -- improved java performance, added options
//###           14 Mar 02  -- Tomas Hurka -- -d support, static initializer workaround
//### Please send bug reports to tom@hukatronic.cz
//### static char yysccsid[] = "@(#)yaccpar	1.8 (Berkeley) 01/20/90";






//#line 2 "compiler.y"
package com.gsdpascal.frontend;
import java.io.*;
import com.gsdpascal.astree.*;
import com.gsdpascal.codegen.*;
import java.util.ArrayList;
//#line 23 "Parser.java"




public class Parser
{

  boolean yydebug;        //do I want debug output?
  int yynerrs;            //number of errors so far
  int yyerrflag;          //was there an error?
  int yychar;             //the current working character

  //########## MESSAGES ##########
//###############################################################
// method: debug
//###############################################################
  void debug(String msg)
  {
    if (yydebug)
      System.out.println(msg);
  }

  //########## STATE STACK ##########
  final static int YYSTACKSIZE = 500;  //maximum stack size
  int statestk[] = new int[YYSTACKSIZE]; //state stack
  int stateptr;
  int stateptrmax;                     //highest index of stackptr
  int statemax;                        //state when highest index reached
  //###############################################################
// methods: state stack push,pop,drop,peek
//###############################################################
  final void state_push(int state)
  {
    try {
      stateptr++;
      statestk[stateptr]=state;
    }
    catch (ArrayIndexOutOfBoundsException e) {
      int oldsize = statestk.length;
      int newsize = oldsize * 2;
      int[] newstack = new int[newsize];
      System.arraycopy(statestk,0,newstack,0,oldsize);
      statestk = newstack;
      statestk[stateptr]=state;
    }
  }
  final int state_pop()
  {
    return statestk[stateptr--];
  }
  final void state_drop(int cnt)
  {
    stateptr -= cnt;
  }
  final int state_peek(int relative)
  {
    return statestk[stateptr-relative];
  }
  //###############################################################
// method: init_stacks : allocate and prepare stacks
//###############################################################
  final boolean init_stacks()
  {
    stateptr = -1;
    val_init();
    return true;
  }
  //###############################################################
// method: dump_stacks : show n levels of the stacks
//###############################################################
  void dump_stacks(int count)
  {
    int i;
    System.out.println("=index==state====value=     s:"+stateptr+"  v:"+valptr);
    for (i=0;i<count;i++)
      System.out.println(" "+i+"    "+statestk[i]+"      "+valstk[i]);
    System.out.println("======================");
  }


//########## SEMANTIC VALUES ##########
//public class ParserVal is defined in ParserVal.java


  String   yytext;//user variable to return contextual strings
  ParserVal yyval; //used to return semantic vals from action routines
  ParserVal yylval;//the 'lval' (result) I got from yylex()
  ParserVal valstk[];
  int valptr;
  //###############################################################
// methods: value stack push,pop,drop,peek.
//###############################################################
  void val_init()
  {
    valstk=new ParserVal[YYSTACKSIZE];
    yyval=new ParserVal();
    yylval=new ParserVal();
    valptr=-1;
  }
  void val_push(ParserVal val)
  {
    if (valptr>=YYSTACKSIZE)
      return;
    valstk[++valptr]=val;
  }
  ParserVal val_pop()
  {
    if (valptr<0)
      return new ParserVal();
    return valstk[valptr--];
  }
  void val_drop(int cnt)
  {
    int ptr;
    ptr=valptr-cnt;
    if (ptr<0)
      return;
    valptr = ptr;
  }
  ParserVal val_peek(int relative)
  {
    int ptr;
    ptr=valptr-relative;
    if (ptr<0)
      return new ParserVal();
    return valstk[ptr];
  }
  final ParserVal dup_yyval(ParserVal val)
  {
    ParserVal dup = new ParserVal();
    dup.ival = val.ival;
    dup.dval = val.dval;
    dup.sval = val.sval;
    dup.obj = val.obj;
    return dup;
  }
  //#### end semantic value section ####
  public final static short T_PROGRAM=257;
  public final static short T_CONST=258;
  public final static short T_TYPE=259;
  public final static short T_VAR=260;
  public final static short T_FUNCTION=261;
  public final static short T_PROCEDURE=262;
  public final static short T_INT=263;
  public final static short T_REAL=264;
  public final static short T_ID=265;
  public final static short T_CHAR=266;
  public final static short T_STRING=267;
  public final static short T_BEGIN=268;
  public final static short T_END=269;
  public final static short T_TRUE=270;
  public final static short T_FALSE=271;
  public final static short T_MAXINT=272;
  public final static short T_READ=273;
  public final static short T_WRITE=274;
  public final static short T_WRITELN=275;
  public final static short T_ABS=276;
  public final static short T_CHR=277;
  public final static short T_ODD=278;
  public final static short T_ORD=279;
  public final static short T_PRED=280;
  public final static short T_SQR=281;
  public final static short T_SQRT=282;
  public final static short T_SUCC=283;
  public final static short T_IF=284;
  public final static short T_THEN=285;
  public final static short T_ELSE=286;
  public final static short T_REPEAT=287;
  public final static short T_UNTIL=288;
  public final static short T_WHILE=289;
  public final static short T_DO=290;
  public final static short T_CASE=291;
  public final static short T_TO=292;
  public final static short T_DOWNTO=293;
  public final static short T_FOR=294;
  public final static short T_EQUAL=295;
  public final static short T_UNEQUAL=296;
  public final static short T_GE=297;
  public final static short T_GT=298;
  public final static short T_LE=299;
  public final static short T_LT=300;
  public final static short T_ASSIGN=301;
  public final static short T_PLUS=302;
  public final static short T_MINUS=303;
  public final static short T_MUL=304;
  public final static short T_DIV=305;
  public final static short T_OR=306;
  public final static short T_AND=307;
  public final static short T_NOT=308;
  public final static short T_MOD=309;
  public final static short T_LB=310;
  public final static short T_RB=311;
  public final static short T_LP=312;
  public final static short T_RP=313;
  public final static short T_SEMI=314;
  public final static short T_DOT=315;
  public final static short T_DOTDOT=316;
  public final static short T_COMMA=317;
  public final static short T_COLON=318;
  public final static short T_INTEGER_TYPE=319;
  public final static short T_BOOLEAN_TYPE=320;
  public final static short T_CHAR_TYPE=321;
  public final static short T_REAL_TYPE=322;
  public final static short T_ARRAY=323;
  public final static short T_OF=324;
  public final static short T_RECORD=325;
  public final static short T_GOTO=326;
  public final static short ERROR=327;
  public final static short YYERRCODE=256;
  final static short yylhs[] = {                           -1,
          0,    0,    0,    0,    1,    2,    3,    3,    3,    3,
          3,    4,    4,    4,    4,    5,    6,    6,    7,    7,
          8,    8,    9,   10,   11,   11,   12,   12,   13,   13,
          14,   14,   15,   15,   16,   16,   17,   17,   17,   17,
          17,   17,   17,   18,   18,   19,   19,   20,   20,   21,
          21,   21,   22,   23,   23,   24,   24,   25,   26,   26,
          26,   26,   26,   26,   26,   26,   26,   26,   27,   27,
          28,   29,   30,   30,   31,   31,   31,   49,   49,   32,
          32,   32,   32,   32,   32,   32,   32,   32,   33,   33,
          33,   34,   35,   35,   36,   36,   37,   37,   47,   38,
          39,   39,   40,   40,   41,   41,   42,   42,   42,   42,
          42,   42,   43,   43,   48,   48,   48,   48,   48,   48,
          48,   44,   44,   44,   44,   45,   45,   45,   45,   45,
          46,   46,   46,   46,   46,   46,   46,   46,   46,   46,
          46,   46,   46,   46,   46,   46,
  };
  final static short yylen[] = {                            2,
          5,    4,    4,    3,    2,    4,    0,    2,    2,    1,
          1,    4,    3,    3,    2,    5,    0,    3,    3,    1,
          4,    3,    4,    3,    0,    2,    2,    1,    4,    3,
          0,    2,    2,    1,    4,    3,    1,    1,    1,    1,
          1,    1,    1,    0,    2,    2,    1,    4,    3,    1,
          1,    1,    3,    2,    1,    4,    3,    6,    1,    3,
          3,    4,    5,    3,    1,    1,    1,    1,    3,    1,
          1,    1,    3,    2,    0,    3,    2,    3,    1,    1,
          1,    1,    1,    1,    1,    1,    1,    1,    3,    6,
          5,    2,    5,    4,    0,    2,    4,    0,    4,    5,
          2,    1,    4,    4,    8,    8,    1,    4,    4,    4,
          1,    4,    3,    1,    3,    3,    3,    3,    3,    3,
          1,    3,    3,    3,    1,    3,    3,    3,    3,    1,
          1,    4,    1,    3,    2,    2,    4,    3,    4,    4,
          4,    4,    4,    4,    4,    4,
  };
  final static short yydefred[] = {                         0,
          0,    0,    0,    0,    0,    0,    0,    0,   71,    0,
          34,    0,    0,    3,   75,    5,   72,    0,    0,   33,
          0,    1,    0,    0,   47,    0,    0,    0,   37,   38,
          39,   40,   41,   42,   43,    0,    0,   73,    0,    0,
          0,    0,   75,    0,    0,    0,    0,    0,   81,   79,
          80,   82,   83,   84,   86,   87,   88,   85,    0,   46,
          0,    0,   28,    0,   70,    0,    0,    0,   10,    0,
          11,    0,   35,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,  133,    0,
          0,    0,  130,    0,    0,    0,    0,    0,   92,    0,
          0,    0,    0,   76,    0,    0,   65,   66,   68,   67,
          0,    0,    0,    0,   52,   51,   50,    0,   27,    0,
          0,    0,    0,    8,    9,    0,    0,    0,   78,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,  136,  135,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,   55,    0,    0,   48,    0,   69,
          0,    0,    0,   24,    0,   14,    0,  109,  110,    0,
          112,    0,    0,    0,    0,    0,    0,    0,    0,  134,
          0,    0,  138,    0,    0,    0,  126,  127,  129,  128,
          0,    0,    0,    0,    0,    0,    0,    0,   94,    0,
          99,    0,    0,    0,  102,    0,    0,  108,    0,    0,
          60,    0,   53,   54,    0,   61,   64,   29,    0,    0,
          20,    0,    0,   12,   23,    0,  139,  140,  141,  142,
          143,  144,  145,  146,  137,  132,   93,   96,    0,    0,
          100,  101,    0,    0,    0,    0,    0,   62,    0,    0,
          0,   18,    0,    0,   16,    0,    0,    0,    0,    0,
          63,    0,   56,    0,   19,   22,  103,  104,    0,    0,
          58,   21,  105,  106,
  };
  final static short yydgoto[] = {                          2,
          6,    7,   68,   69,   70,  183,  240,  241,   71,   72,
          28,   62,   63,    8,   10,   11,   89,   19,   24,   25,
          114,  115,  174,  175,  116,  117,   64,   90,   16,   49,
          23,   50,   51,   52,   53,  219,   54,   55,  224,  225,
          56,   57,  131,   91,   92,   93,   58,  132,   59,
  };
  final static short yysindex[] = {                      -245,
          -235,    0, -255, -223, -207, -257, -192, -190,    0, -223,
          0, -202, -212,    0,    0,    0,    0, -223, -148,    0,
          713,    0, -246, -223,    0, -178, -223, -222,    0,    0,
          0,    0,    0,    0,    0, -189, -181,    0, -165, -157,
          -136, 1301,    0, 1301, 1301, -223,  -84, -199,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0, -123,    0,
          1137, -223,    0, -261,    0,  -63,  -55, -222,    0, -244,
          0,  -99,    0, 1097, 1301, 1301, 1301,  -95,  -73,  -64,
          -61,  -56,  -44,  -41,  -39, 1301, 1301, 1301,    0, -205,
          -219, -289,    0, 1057,  -88,   42, -264,  -85,    0, 1301,
          1301, 1301, -223,    0,  713, -223,    0,    0,    0,    0,
          -76, -223,  -67,  -33,    0,    0,    0,  -57,    0, -223,
          1137,  -32,  -32,    0,    0, -207,   -3, -207,    0,  -31,
          -198,  222, -193, 1301, 1301, 1301, 1301, 1301, 1301, 1301,
          1301,    0,    0,  -53, 1301, 1301, -223, 1301, 1301, 1301,
          1301, 1301, 1301, 1301,  -54, 1301, 1301, 1301, 1301, 1301,
          1301,   27, 1301,  -54,  467, 1301,  222,  496, -185,   18,
          12, -147, 1201,  -96,    0, -173,  713,    0, -223,    0,
          17, -239,   15,    0,   29,    0,   30,    0,    0, 1301,
          0, -105,  -81,  -34,    3,    4,   49,  173,  180,    0,
          559,  195,    0, -289, -289, -289,    0,    0,    0,    0,
          27, -219, -219, -219, -219, -219, -219,  -54,    0,  222,
          0,   47,   50,  407,    0,  808,   72,    0, 1301, -217,
          0,   68,    0,    0, 1137,    0,    0,    0, -223, -156,
          0, -129, 1201,    0,    0,  222,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,  -54,  -54,
          0,    0, 1301, 1301, 1301,  222,  713,    0,   56,   67,
          -113,    0, -239, 1201,    0,   74,   77,  102,  162,  222,
          0, 1137,    0, 1201,    0,    0,    0,    0,  -54,  -54,
          0,    0,    0,    0,
  };
  final static short yyrindex[] = {                         0,
          0,    0,  -97,    0,  -97,  393,    0, -109,    0,  -37,
          0,    0,  403,    0,    0,    0,    0,    0, -139,    0,
          0,    0,  302,  -78,    0,    0,    0,  136,    0,    0,
          0,    0,    0,    0,    0,   -7,    0,    0,    0,    0,
          735,    0,    0,    0,    0,    0,    0,  921,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,  955,    0,
          0,   16,    0,    0,    0,    0,    0,  154,    0,  -97,
          0,    0,    0, 1025,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    1,
          309,   61,    0,  610,  111,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0, -194,    0,    0,    0, -119,    0,    0,
          0,  108,  114,    0,    0,  -97,  109,  -97,    0,    0,
          0,  229,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,  610,    0,    0,    0,    0,    0,
          0,  991,    0,  610,    0,    0,  769,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          -183,    0,    0,    0,  169,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,  121,  181,  241,    0,    0,    0,    0,
          991,  369,  429,  489,  549,  615,  675,  610,    0,  805,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
          0,    0,    0,    0,    0,  240,    0,    0,    0,    0,
          0,    0,    0,    0,    0,    0,    0,    0,  111,  111,
          0,    0,    0,    0,    0,  853,    0,    0,    0,  -91,
          0,    0,    0,    0,    0,    0,    0,    0,    0,  887,
          0,    0,    0,    0,    0,    0,    0,    0,  610,  610,
          0,    0,    0,    0,
  };
  final static short yygindex[] = {                         0,
          5,    0,    0,  365,    0,  316,    0,  167,  373,    0,
          0,    0,  386,    0,    0,  441,  -17,    0,    0,  439,
          -121,    0,    0,  279,    0, -166, -101, 1273,    0,  457,
          442,  408,    0,    0,    0,  277,    0,    0,    0,  267,
          0,    0,  -40,  490,  -14,  -62,    0,  -36,  -92,
  };
  final static int YYTABLESIZE=1613;
  static short yytable[];
  static { yytable();}
  static void yytable(){
    yytable = new short[]{                        181,
            131,  162,    4,   36,  172,   94,  232,   96,   97,   13,
            176,    1,  130,    4,  151,  152,   37,  153,    9,  154,
            239,   15,   38,  142,  143,    9,   39,   40,   41,    3,
            156,  157,  158,  159,  160,  161,  133,   42,   66,   67,
            43,    9,   44,  113,   45,   29,   30,   46,   31,   32,
            4,  144,   33,   34,   35,  120,  121,   14,    5,  165,
            125,  169,  211,  167,  168,   49,   49,   49,   18,  126,
            49,  221,  176,   49,  127,   15,  275,   30,   30,   47,
            242,   30,  148,  149,   30,  267,  150,  171,  207,  208,
            209,  210,   21,  192,  193,  194,  195,  196,  197,  198,
            199,  100,   22,  113,  145,  202,  146,  286,  201,  147,
            101,   27,  102,  270,  189,  103,   61,  292,  190,  191,
            122,   25,   25,  190,   73,  258,  220,  228,   25,  226,
            185,  190,  187,  204,  205,  206,   74,  271,   59,   59,
            59,   59,   59,  120,  235,   59,   75,  222,   59,   59,
            44,   44,   44,  246,   76,  113,  272,  273,   44,  236,
            291,   31,   31,   31,   31,  231,  276,  277,    9,  120,
            31,  242,  233,   57,   37,   77,    9,   57,   99,   15,
            123,   45,   45,   45,   39,   40,   41,  120,  274,   45,
            104,   59,  266,   59,   59,   42,  293,  294,   43,  163,
            44,  122,   45,  120,  284,   46,  222,  247,   37,  123,
            9,  190,  268,   15,  128,  166,  134,  113,   39,   40,
            41,   32,   32,   32,   32,  113,  278,  279,  280,   42,
            32,  248,   43,  173,   44,  190,   45,   47,  135,   46,
            124,  156,  157,  158,  159,  160,  161,  136,  177,  281,
            137,   36,   36,   36,   36,  138,  113,   36,  179,  200,
            36,  131,  131,  131,  113,  131,  113,  139,  131,  131,
            140,   47,  141,  131,  131,  131,   26,   26,  249,  182,
            178,  188,  190,   26,  131,  131,  131,  131,  131,  131,
            131,  131,  131,  131,  131,  131,  131,  131,  131,  131,
            131,   74,  131,  131,  131,  131,  131,  131,  121,  131,
            186,  131,  218,  131,  131,  250,  251,  131,  229,  190,
            190,  125,  125,  125,  131,  125,  131,  230,  125,  125,
            238,  164,  243,  125,  125,  125,  156,  157,  158,  159,
            160,  161,  244,  245,  125,  125,  125,  125,  125,  125,
            125,  125,  125,  125,  125,  125,  125,  125,  125,  125,
            125,  252,  125,  125,  259,  190,  125,  260,  119,   15,
            15,  125,  265,  125,  125,  125,   15,  125,  269,  282,
            283,  122,  122,  122,  125,  122,  125,  287,  122,  122,
            288,  289,    4,  122,  122,  122,  156,  157,  158,  159,
            160,  161,    2,    7,  122,  122,  122,  122,  122,  122,
            122,  122,  122,  122,  122,  122,  122,  122,  122,  122,
            122,    6,  122,  122,   98,   17,  122,   17,  120,   13,
            13,  122,  124,  122,  122,  122,   13,  122,  184,  285,
            125,  123,  123,  123,  122,  123,  122,  119,  123,  123,
            20,  290,  234,  123,  123,  123,  156,  157,  158,  159,
            160,  161,   60,   17,  123,  123,  123,  123,  123,  123,
            123,  123,  123,  123,  123,  123,  123,  123,  123,  123,
            123,  129,  123,  123,   95,  253,  123,  257,  115,  190,
            262,  123,  254,  123,  123,  123,  190,  123,    0,    0,
            0,  124,  124,  124,  123,  124,  123,  256,  124,  124,
            0,  190,    0,  124,  124,  124,  156,  157,  158,  159,
            160,  161,    0,    0,  124,  124,  124,  124,  124,  124,
            124,  124,  124,  124,  124,  124,  124,  124,  124,  124,
            124,  114,  124,  124,    0,  114,  124,    0,  116,    0,
            0,  124,  113,  124,  124,  124,  113,  124,    0,    0,
            0,    0,   74,   74,  124,    0,  124,    0,    0,  121,
            121,  121,    0,  121,    0,    0,  121,  121,    0,    0,
            0,  121,  121,  121,    0,    0,    0,   74,    0,   74,
            0,    0,  121,  121,  121,  121,  121,  121,  121,  121,
            121,  121,  121,  121,  121,  121,  121,  121,  121,   98,
            0,    0,    0,    0,  117,   74,   74,    0,    0,  121,
            0,  121,  121,  121,    0,  121,    0,    0,    0,  119,
            119,  119,  121,  119,  121,    0,  119,  119,    0,    0,
            0,  119,  119,  119,    0,  212,  213,  214,  215,  216,
            217,    0,  119,  119,  119,  119,  119,  119,  119,  119,
            119,  119,  119,  119,  119,  119,  119,  119,  119,   29,
            30,    9,   31,   32,  118,  261,   33,   34,   35,  119,
            0,  119,  119,  119,    0,  119,    0,    0,    0,  120,
            120,  120,  119,  120,  119,    0,  120,  120,    0,    0,
            0,  120,  120,  120,    0,    0,    0,    0,    0,    0,
            0,    0,  120,  120,  120,  120,  120,  120,  120,  120,
            120,  120,  120,  120,  120,  120,  120,  120,  120,   29,
            30,    9,   31,   32,  111,    0,   33,   34,   35,  120,
            0,  120,  120,  120,    0,  120,    0,    0,    0,  115,
            115,  115,  120,  115,  120,    0,  115,  115,    0,    0,
            0,  115,  115,  115,    0,    0,    0,    0,   89,    0,
            0,    0,  115,  115,  115,  115,  115,  115,  115,  115,
            115,  115,  115,  115,  115,  115,  115,  115,  115,    0,
            156,  157,  158,  159,  160,  161,    0,    0,    0,  115,
            0,  115,  115,  115,   97,  115,  227,    0,    0,  116,
            116,  116,  115,  116,  115,    0,  116,  116,    0,    0,
            0,  116,  116,  116,    0,    0,    0,    0,    0,    0,
            0,    0,  116,  116,  116,  116,  116,  116,  116,  116,
            116,  116,  116,  116,  116,  116,  116,  116,  116,    0,
            0,    0,   91,  156,  157,  158,  159,  160,  161,  116,
            0,  116,  116,  116,    0,  116,    0,    0,    0,  255,
            98,   98,  116,    0,  116,  117,  117,  117,   98,  117,
            0,    0,  117,  117,    0,    0,   90,  117,  117,  117,
            0,    0,    0,    0,    0,   98,    0,   98,  117,  117,
            117,  117,  117,  117,  117,  117,  117,  117,  117,  117,
            117,  117,  117,  117,  117,    0,    0,    0,    0,    0,
            107,    0,    0,   98,   98,  117,    0,  117,  117,  117,
            0,  117,    0,    0,    0,  118,  118,  118,  117,  118,
            117,    0,  118,  118,    0,    0,    0,  118,  118,  118,
            0,    0,    0,    0,   77,    0,    0,    0,  118,  118,
            118,  118,  118,  118,  118,  118,  118,  118,  118,  118,
            118,  118,  118,  118,  118,   29,   30,    0,   31,   32,
            0,    0,   33,   34,   35,  118,    0,  118,  118,  118,
            95,  118,    0,    0,    0,  111,  111,  111,  118,  111,
            118,    0,  111,  111,    0,    0,    0,  111,  111,  111,
            0,    0,    0,    0,    0,    0,    0,    0,  111,    0,
            111,  111,  111,  111,   98,  111,    0,    0,  111,   89,
            89,   89,    0,   89,    0,    0,   89,   89,    0,    0,
            0,   89,   89,   89,    0,    0,    0,    0,  111,  111,
            0,    0,   89,    0,   89,   89,   89,   89,    0,   89,
            111,    0,   89,    0,    0,   97,   97,   97,    0,   97,
            0,    0,   97,   97,    0,    0,    0,   97,   97,   97,
            0,    0,   89,   89,    0,    0,    0,    0,   97,    0,
            97,   97,   97,   97,   89,   97,    0,    0,   97,  263,
            264,    0,  156,  157,  158,  159,  160,  161,    0,    0,
            0,    0,    0,   91,   91,   91,    0,   91,   97,   97,
            91,   91,    0,    0,    0,   91,   91,   91,    0,    0,
            97,    0,    0,    0,    0,    0,   91,    0,   91,   91,
            91,   91,    0,   91,    0,    0,   91,   90,   90,   90,
            0,   90,    0,    0,   90,   90,    0,    0,    0,   90,
            90,   90,    0,    0,    0,    0,   91,   91,    0,    0,
            90,    0,   90,   90,   90,   90,    0,   90,   91,    0,
            90,  107,  107,  107,    0,  107,    0,    0,  107,  107,
            0,    0,    0,  107,  107,  107,    0,    0,    0,    0,
            90,   90,    0,    0,  107,    0,  107,  107,  107,  107,
            0,  107,   90,    0,  107,   77,   77,   77,    0,   77,
            0,    0,   77,   77,    0,    0,    0,   77,   77,   77,
            0,    0,    0,    0,  107,    0,    0,    0,   77,    0,
            77,   77,   77,   77,    0,   77,  107,    0,   77,    0,
            0,   95,   95,   95,    0,   95,    0,    0,   95,   95,
            0,    0,    0,   95,   95,   95,    0,    0,    0,   77,
            0,    0,    0,    0,   95,    0,   12,   95,   95,   95,
            77,   95,   12,    0,   95,   98,   98,   98,    0,    0,
            26,    0,    0,   98,    0,   48,   26,    0,    0,   65,
            0,    0,    0,    0,   95,   95,    0,    0,    0,    0,
            98,    0,   98,    0,    0,    0,   95,    0,   98,   37,
            0,    9,    0,    0,   15,    0,    0,    0,    0,   39,
            40,   41,    0,  118,   65,    0,    0,    0,   98,   98,
            42,  155,    0,   43,    0,   44,   48,   45,    0,    0,
            46,  156,  157,  158,  159,  160,  161,    0,    0,    0,
            0,    9,    0,    0,   15,    0,   48,   48,    0,   39,
            40,   41,    0,    0,    0,  170,    0,    0,   65,    0,
            42,    0,   47,   43,   65,   44,    0,   45,    0,    0,
            46,    0,  180,  118,    0,    0,    0,    0,    0,   29,
            30,    9,   31,   32,    0,    0,   33,   34,   35,    0,
            0,    0,    0,    0,    0,    0,    0,    0,    0,  203,
            0,    0,   47,    0,    0,    0,    0,   48,    0,    0,
            0,    0,    0,    0,    0,    0,   48,  223,    0,  105,
            0,    0,    0,    0,    0,  118,   65,    0,  106,    0,
            0,  237,    0,    0,   65,  107,  108,  109,  110,  111,
            0,  112,    0,   29,   30,    9,   31,   32,    0,    0,
            33,   34,   35,    0,    0,    0,    0,    0,    0,    0,
            0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
            48,    0,    0,    0,    0,    0,  223,    0,    0,    0,
            0,    0,    0,  105,    0,    0,    0,  118,    0,    0,
            0,   65,  106,    0,    0,  118,    0,    0,    0,  107,
            108,  109,  110,    0,    0,    0,    0,    0,    0,    0,
            0,   48,   48,    0,    0,    0,    0,    0,    0,    0,
            0,    0,    0,    0,    0,   65,  118,    0,    0,    0,
            0,    0,    0,    0,  118,    0,  118,    0,    0,    0,
            0,   48,   48,   29,   30,    9,   31,   32,    0,    0,
            33,   34,   35,    0,    0,    0,   78,   79,   80,   81,
            82,   83,   84,   85,    0,    0,    0,    0,    0,    0,
            0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
            0,    0,    0,   86,    0,    0,    0,    0,   87,    0,
            0,    0,   88,
    };
  }
  static short yycheck[];
  static { yycheck(); }
  static void yycheck() {
    yycheck = new short[] {                        121,
            0,   94,  258,   21,  106,   42,  173,   44,   45,    5,
            112,  257,   75,  258,  304,  305,  263,  307,  265,  309,
            260,  268,  269,   86,   87,  265,  273,  274,  275,  265,
            295,  296,  297,  298,  299,  300,   77,  284,  261,  262,
            287,  265,  289,   61,  291,  263,  264,  294,  266,  267,
            258,   88,  270,  271,  272,  317,  318,  315,  314,  324,
            0,  102,  155,  100,  101,  260,  261,  262,  259,  314,
            265,  164,  174,  268,   70,  268,  243,  261,  262,  326,
            182,  265,  302,  303,  268,  303,  306,  105,  151,  152,
            153,  154,  295,  134,  135,  136,  137,  138,  139,  140,
            141,  301,  315,  121,  310,  146,  312,  274,  145,  315,
            310,  260,  312,  235,  313,  315,  295,  284,  317,  313,
            0,  261,  262,  317,  314,  218,  163,  313,  268,  166,
            126,  317,  128,  148,  149,  150,  318,  239,  258,  259,
            260,  261,  262,  317,  318,  265,  312,  165,  268,  269,
            260,  261,  262,  190,  312,  173,  313,  314,  268,  177,
            282,  259,  260,  261,  262,  313,  259,  260,  265,  317,
            268,  273,  269,  265,  263,  312,  265,  269,  263,  268,
            0,  260,  261,  262,  273,  274,  275,  317,  318,  268,
            314,  311,  229,  313,  314,  284,  289,  290,  287,  288,
            289,  265,  291,  317,  318,  294,  224,  313,  263,  265,
            265,  317,  230,  268,  314,  301,  312,  235,  273,  274,
            275,  259,  260,  261,  262,  243,  263,  264,  265,  284,
            268,  313,  287,  310,  289,  317,  291,  326,  312,  294,
            0,  295,  296,  297,  298,  299,  300,  312,  316,  267,
            312,  259,  260,  261,  262,  312,  274,  265,  316,  313,
            268,  261,  262,  263,  282,  265,  284,  312,  268,  269,
            312,  326,  312,  273,  274,  275,  261,  262,  313,  312,
            314,  313,  317,  268,  284,  285,  286,  287,  288,  289,
            290,  291,  292,  293,  294,  295,  296,  297,  298,  299,
            300,    0,  302,  303,  304,  305,  306,  307,    0,  309,
            314,  311,  286,  313,  314,  313,  313,  317,  301,  317,
            317,  261,  262,  263,  324,  265,  326,  316,  268,  269,
            314,  290,  318,  273,  274,  275,  295,  296,  297,  298,
            299,  300,  314,  314,  284,  285,  286,  287,  288,  289,
            290,  291,  292,  293,  294,  295,  296,  297,  298,  299,
            300,  313,  302,  303,  318,  317,  306,  318,    0,  261,
            262,  311,  301,  313,  314,  315,  268,  317,  311,  324,
            314,  261,  262,  263,  324,  265,  326,  314,  268,  269,
            314,  290,    0,  273,  274,  275,  295,  296,  297,  298,
            299,  300,    0,  268,  284,  285,  286,  287,  288,  289,
            290,  291,  292,  293,  294,  295,  296,  297,  298,  299,
            300,  268,  302,  303,  314,  318,  306,  314,    0,  261,
            262,  311,   68,  313,  314,  315,  268,  317,  123,  273,
            68,  261,  262,  263,  324,  265,  326,   62,  268,  269,
            10,  290,  174,  273,  274,  275,  295,  296,  297,  298,
            299,  300,   24,    7,  284,  285,  286,  287,  288,  289,
            290,  291,  292,  293,  294,  295,  296,  297,  298,  299,
            300,   74,  302,  303,   43,  313,  306,  211,    0,  317,
            224,  311,  313,  313,  314,  315,  317,  317,   -1,   -1,
            -1,  261,  262,  263,  324,  265,  326,  313,  268,  269,
            -1,  317,   -1,  273,  274,  275,  295,  296,  297,  298,
            299,  300,   -1,   -1,  284,  285,  286,  287,  288,  289,
            290,  291,  292,  293,  294,  295,  296,  297,  298,  299,
            300,  313,  302,  303,   -1,  317,  306,   -1,    0,   -1,
            -1,  311,  313,  313,  314,  315,  317,  317,   -1,   -1,
            -1,   -1,  261,  262,  324,   -1,  326,   -1,   -1,  261,
            262,  263,   -1,  265,   -1,   -1,  268,  269,   -1,   -1,
            -1,  273,  274,  275,   -1,   -1,   -1,  286,   -1,  288,
            -1,   -1,  284,  285,  286,  287,  288,  289,  290,  291,
            292,  293,  294,  295,  296,  297,  298,  299,  300,    0,
            -1,   -1,   -1,   -1,    0,  314,  315,   -1,   -1,  311,
            -1,  313,  314,  315,   -1,  317,   -1,   -1,   -1,  261,
            262,  263,  324,  265,  326,   -1,  268,  269,   -1,   -1,
            -1,  273,  274,  275,   -1,  156,  157,  158,  159,  160,
            161,   -1,  284,  285,  286,  287,  288,  289,  290,  291,
            292,  293,  294,  295,  296,  297,  298,  299,  300,  263,
            264,  265,  266,  267,    0,  269,  270,  271,  272,  311,
            -1,  313,  314,  315,   -1,  317,   -1,   -1,   -1,  261,
            262,  263,  324,  265,  326,   -1,  268,  269,   -1,   -1,
            -1,  273,  274,  275,   -1,   -1,   -1,   -1,   -1,   -1,
            -1,   -1,  284,  285,  286,  287,  288,  289,  290,  291,
            292,  293,  294,  295,  296,  297,  298,  299,  300,  263,
            264,  265,  266,  267,    0,   -1,  270,  271,  272,  311,
            -1,  313,  314,  315,   -1,  317,   -1,   -1,   -1,  261,
            262,  263,  324,  265,  326,   -1,  268,  269,   -1,   -1,
            -1,  273,  274,  275,   -1,   -1,   -1,   -1,    0,   -1,
            -1,   -1,  284,  285,  286,  287,  288,  289,  290,  291,
            292,  293,  294,  295,  296,  297,  298,  299,  300,   -1,
            295,  296,  297,  298,  299,  300,   -1,   -1,   -1,  311,
            -1,  313,  314,  315,    0,  317,  311,   -1,   -1,  261,
            262,  263,  324,  265,  326,   -1,  268,  269,   -1,   -1,
            -1,  273,  274,  275,   -1,   -1,   -1,   -1,   -1,   -1,
            -1,   -1,  284,  285,  286,  287,  288,  289,  290,  291,
            292,  293,  294,  295,  296,  297,  298,  299,  300,   -1,
            -1,   -1,    0,  295,  296,  297,  298,  299,  300,  311,
            -1,  313,  314,  315,   -1,  317,   -1,   -1,   -1,  311,
            261,  262,  324,   -1,  326,  261,  262,  263,  269,  265,
            -1,   -1,  268,  269,   -1,   -1,    0,  273,  274,  275,
            -1,   -1,   -1,   -1,   -1,  286,   -1,  288,  284,  285,
            286,  287,  288,  289,  290,  291,  292,  293,  294,  295,
            296,  297,  298,  299,  300,   -1,   -1,   -1,   -1,   -1,
            0,   -1,   -1,  314,  315,  311,   -1,  313,  314,  315,
            -1,  317,   -1,   -1,   -1,  261,  262,  263,  324,  265,
            326,   -1,  268,  269,   -1,   -1,   -1,  273,  274,  275,
            -1,   -1,   -1,   -1,    0,   -1,   -1,   -1,  284,  285,
            286,  287,  288,  289,  290,  291,  292,  293,  294,  295,
            296,  297,  298,  299,  300,  263,  264,   -1,  266,  267,
            -1,   -1,  270,  271,  272,  311,   -1,  313,  314,  315,
            0,  317,   -1,   -1,   -1,  261,  262,  263,  324,  265,
            326,   -1,  268,  269,   -1,   -1,   -1,  273,  274,  275,
            -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  284,   -1,
            286,  287,  288,  289,    0,  291,   -1,   -1,  294,  261,
            262,  263,   -1,  265,   -1,   -1,  268,  269,   -1,   -1,
            -1,  273,  274,  275,   -1,   -1,   -1,   -1,  314,  315,
            -1,   -1,  284,   -1,  286,  287,  288,  289,   -1,  291,
            326,   -1,  294,   -1,   -1,  261,  262,  263,   -1,  265,
            -1,   -1,  268,  269,   -1,   -1,   -1,  273,  274,  275,
            -1,   -1,  314,  315,   -1,   -1,   -1,   -1,  284,   -1,
            286,  287,  288,  289,  326,  291,   -1,   -1,  294,  292,
            293,   -1,  295,  296,  297,  298,  299,  300,   -1,   -1,
            -1,   -1,   -1,  261,  262,  263,   -1,  265,  314,  315,
            268,  269,   -1,   -1,   -1,  273,  274,  275,   -1,   -1,
            326,   -1,   -1,   -1,   -1,   -1,  284,   -1,  286,  287,
            288,  289,   -1,  291,   -1,   -1,  294,  261,  262,  263,
            -1,  265,   -1,   -1,  268,  269,   -1,   -1,   -1,  273,
            274,  275,   -1,   -1,   -1,   -1,  314,  315,   -1,   -1,
            284,   -1,  286,  287,  288,  289,   -1,  291,  326,   -1,
            294,  261,  262,  263,   -1,  265,   -1,   -1,  268,  269,
            -1,   -1,   -1,  273,  274,  275,   -1,   -1,   -1,   -1,
            314,  315,   -1,   -1,  284,   -1,  286,  287,  288,  289,
            -1,  291,  326,   -1,  294,  261,  262,  263,   -1,  265,
            -1,   -1,  268,  269,   -1,   -1,   -1,  273,  274,  275,
            -1,   -1,   -1,   -1,  314,   -1,   -1,   -1,  284,   -1,
            286,  287,  288,  289,   -1,  291,  326,   -1,  294,   -1,
            -1,  261,  262,  263,   -1,  265,   -1,   -1,  268,  269,
            -1,   -1,   -1,  273,  274,  275,   -1,   -1,   -1,  315,
            -1,   -1,   -1,   -1,  284,   -1,    4,  287,  288,  289,
            326,  291,   10,   -1,  294,  261,  262,  263,   -1,   -1,
            18,   -1,   -1,  269,   -1,   23,   24,   -1,   -1,   27,
            -1,   -1,   -1,   -1,  314,  315,   -1,   -1,   -1,   -1,
            286,   -1,  288,   -1,   -1,   -1,  326,   -1,   46,  263,
            -1,  265,   -1,   -1,  268,   -1,   -1,   -1,   -1,  273,
            274,  275,   -1,   61,   62,   -1,   -1,   -1,  314,  315,
            284,  285,   -1,  287,   -1,  289,   74,  291,   -1,   -1,
            294,  295,  296,  297,  298,  299,  300,   -1,   -1,   -1,
            -1,  265,   -1,   -1,  268,   -1,   94,   95,   -1,  273,
            274,  275,   -1,   -1,   -1,  103,   -1,   -1,  106,   -1,
            284,   -1,  326,  287,  112,  289,   -1,  291,   -1,   -1,
            294,   -1,  120,  121,   -1,   -1,   -1,   -1,   -1,  263,
            264,  265,  266,  267,   -1,   -1,  270,  271,  272,   -1,
            -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  147,
            -1,   -1,  326,   -1,   -1,   -1,   -1,  155,   -1,   -1,
            -1,   -1,   -1,   -1,   -1,   -1,  164,  165,   -1,  303,
            -1,   -1,   -1,   -1,   -1,  173,  174,   -1,  312,   -1,
            -1,  179,   -1,   -1,  182,  319,  320,  321,  322,  323,
            -1,  325,   -1,  263,  264,  265,  266,  267,   -1,   -1,
            270,  271,  272,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
            -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
            218,   -1,   -1,   -1,   -1,   -1,  224,   -1,   -1,   -1,
            -1,   -1,   -1,  303,   -1,   -1,   -1,  235,   -1,   -1,
            -1,  239,  312,   -1,   -1,  243,   -1,   -1,   -1,  319,
            320,  321,  322,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
            -1,  259,  260,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
            -1,   -1,   -1,   -1,   -1,  273,  274,   -1,   -1,   -1,
            -1,   -1,   -1,   -1,  282,   -1,  284,   -1,   -1,   -1,
            -1,  289,  290,  263,  264,  265,  266,  267,   -1,   -1,
            270,  271,  272,   -1,   -1,   -1,  276,  277,  278,  279,
            280,  281,  282,  283,   -1,   -1,   -1,   -1,   -1,   -1,
            -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
            -1,   -1,   -1,  303,   -1,   -1,   -1,   -1,  308,   -1,
            -1,   -1,  312,
    };
  }
  final static short YYFINAL=2;
  final static short YYMAXTOKEN=327;
  final static String yyname[] = {
          "end-of-file",null,null,null,null,null,null,null,null,null,null,null,null,null,
          null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
          null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
          null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
          null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
          null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
          null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
          null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
          null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
          null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
          null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
          null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
          null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
          null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
          null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
          null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
          null,null,null,"T_PROGRAM","T_CONST","T_TYPE","T_VAR","T_FUNCTION",
          "T_PROCEDURE","T_INT","T_REAL","T_ID","T_CHAR","T_STRING","T_BEGIN","T_END",
          "T_TRUE","T_FALSE","T_MAXINT","T_READ","T_WRITE","T_WRITELN","T_ABS","T_CHR",
          "T_ODD","T_ORD","T_PRED","T_SQR","T_SQRT","T_SUCC","T_IF","T_THEN","T_ELSE",
          "T_REPEAT","T_UNTIL","T_WHILE","T_DO","T_CASE","T_TO","T_DOWNTO","T_FOR",
          "T_EQUAL","T_UNEQUAL","T_GE","T_GT","T_LE","T_LT","T_ASSIGN","T_PLUS","T_MINUS",
          "T_MUL","T_DIV","T_OR","T_AND","T_NOT","T_MOD","T_LB","T_RB","T_LP","T_RP",
          "T_SEMI","T_DOT","T_DOTDOT","T_COMMA","T_COLON","T_INTEGER_TYPE",
          "T_BOOLEAN_TYPE","T_CHAR_TYPE","T_REAL_TYPE","T_ARRAY","T_OF","T_RECORD",
          "T_GOTO","ERROR",
  };
  final static String yyrule[] = {
          "$accept : program",
          "program : T_PROGRAM T_ID T_SEMI routine T_DOT",
          "program : T_PROGRAM T_ID T_SEMI routine",
          "program : T_PROGRAM T_ID routine T_DOT",
          "program : T_PROGRAM T_ID routine",
          "routine : routine_head routine_body",
          "routine_head : const_part type_part var_part routine_part",
          "routine_part :",
          "routine_part : routine_part function_decl",
          "routine_part : routine_part procedure_decl",
          "routine_part : function_decl",
          "routine_part : procedure_decl",
          "function_decl : function_head T_SEMI routine T_SEMI",
          "function_decl : function_head T_SEMI routine",
          "function_decl : function_head routine T_SEMI",
          "function_decl : function_head routine",
          "function_head : T_FUNCTION T_ID parameters T_COLON simple_type_decl",
          "parameters :",
          "parameters : T_LP para_decl_list T_RP",
          "para_decl_list : para_decl_list T_SEMI para_type_list",
          "para_decl_list : para_type_list",
          "para_type_list : T_VAR name_list T_COLON simple_type_decl",
          "para_type_list : name_list T_COLON simple_type_decl",
          "procedure_decl : procedure_head T_SEMI routine T_SEMI",
          "procedure_head : T_PROCEDURE T_ID parameters",
          "var_part :",
          "var_part : T_VAR var_decl_list",
          "var_decl_list : var_decl_list var_decl",
          "var_decl_list : var_decl",
          "var_decl : name_list T_COLON type_decl T_SEMI",
          "var_decl : name_list T_COLON type_decl",
          "const_part :",
          "const_part : T_CONST const_expr_list",
          "const_expr_list : const_expr_list const_expr",
          "const_expr_list : const_expr",
          "const_expr : ID T_EQUAL const_value T_SEMI",
          "const_expr : ID T_EQUAL const_value",
          "const_value : T_INT",
          "const_value : T_REAL",
          "const_value : T_CHAR",
          "const_value : T_STRING",
          "const_value : T_TRUE",
          "const_value : T_FALSE",
          "const_value : T_MAXINT",
          "type_part :",
          "type_part : T_TYPE type_decl_list",
          "type_decl_list : type_decl_list type_definition",
          "type_decl_list : type_definition",
          "type_definition : ID T_EQUAL type_decl T_SEMI",
          "type_definition : ID T_EQUAL type_decl",
          "type_decl : simple_type_decl",
          "type_decl : array_type_decl",
          "type_decl : record_type_decl",
          "record_type_decl : T_RECORD field_decl_list T_END",
          "field_decl_list : field_decl_list field_decl",
          "field_decl_list : field_decl",
          "field_decl : name_list T_COLON type_decl T_SEMI",
          "field_decl : name_list T_COLON type_decl",
          "array_type_decl : T_ARRAY T_LB simple_type_decl T_RB T_OF type_decl",
          "simple_type_decl : ID",
          "simple_type_decl : T_LP name_list T_RP",
          "simple_type_decl : const_value T_DOTDOT const_value",
          "simple_type_decl : T_MINUS const_value T_DOTDOT const_value",
          "simple_type_decl : T_MINUS const_value T_DOTDOT T_MINUS const_value",
          "simple_type_decl : ID T_DOTDOT ID",
          "simple_type_decl : T_INTEGER_TYPE",
          "simple_type_decl : T_BOOLEAN_TYPE",
          "simple_type_decl : T_REAL_TYPE",
          "simple_type_decl : T_CHAR_TYPE",
          "name_list : name_list T_COMMA ID",
          "name_list : ID",
          "ID : T_ID",
          "routine_body : compound_stmt",
          "compound_stmt : T_BEGIN stmt_list T_END",
          "compound_stmt : T_BEGIN stmt_list",
          "stmt_list :",
          "stmt_list : stmt_list stmt T_SEMI",
          "stmt_list : stmt_list stmt",
          "stmt : T_INT T_COLON no_label_stmt",
          "stmt : no_label_stmt",
          "no_label_stmt : assign_stmt",
          "no_label_stmt : compound_stmt",
          "no_label_stmt : goto_stmt",
          "no_label_stmt : if_stmt",
          "no_label_stmt : repeat_stmt",
          "no_label_stmt : while_stmt",
          "no_label_stmt : case_stmt",
          "no_label_stmt : for_stmt",
          "no_label_stmt : proc_stmt",
          "assign_stmt : ID T_ASSIGN expression",
          "assign_stmt : ID T_LB expression T_RB T_ASSIGN expression",
          "assign_stmt : ID T_DOT ID T_ASSIGN expression",
          "goto_stmt : T_GOTO T_INT",
          "if_stmt : T_IF expression T_THEN stmt else_clause",
          "if_stmt : T_IF expression stmt else_clause",
          "else_clause :",
          "else_clause : T_ELSE stmt",
          "repeat_stmt : T_REPEAT stmt_list T_UNTIL expression",
          "repeat_stmt :",
          "while_stmt : T_WHILE expression T_DO stmt",
          "case_stmt : T_CASE expression T_OF case_expr_list T_END",
          "case_expr_list : case_expr_list case_expr",
          "case_expr_list : case_expr",
          "case_expr : const_value T_COLON stmt T_SEMI",
          "case_expr : ID T_COLON stmt T_SEMI",
          "for_stmt : T_FOR ID T_ASSIGN expression T_TO expression T_DO stmt",
          "for_stmt : T_FOR ID T_ASSIGN expression T_DOWNTO expression T_DO stmt",
          "proc_stmt : ID",
          "proc_stmt : ID T_LP args_list T_RP",
          "proc_stmt : T_READ T_LP factor T_RP",
          "proc_stmt : T_WRITE T_LP args_list T_RP",
          "proc_stmt : T_WRITELN",
          "proc_stmt : T_WRITELN T_LP args_list T_RP",
          "args_list : args_list T_COMMA expression",
          "args_list : expression",
          "expression : expression T_GE expr",
          "expression : expression T_GT expr",
          "expression : expression T_LE expr",
          "expression : expression T_LT expr",
          "expression : expression T_EQUAL expr",
          "expression : expression T_UNEQUAL expr",
          "expression : expr",
          "expr : expr T_PLUS term",
          "expr : expr T_MINUS term",
          "expr : expr T_OR term",
          "expr : term",
          "term : term T_MUL factor",
          "term : term T_DIV factor",
          "term : term T_MOD factor",
          "term : term T_AND factor",
          "term : factor",
          "factor : ID",
          "factor : ID T_LP args_list T_RP",
          "factor : const_value",
          "factor : T_LP expression T_RP",
          "factor : T_NOT factor",
          "factor : T_MINUS factor",
          "factor : ID T_LB expression T_RB",
          "factor : ID T_DOT ID",
          "factor : T_ABS T_LP args_list T_RP",
          "factor : T_CHR T_LP args_list T_RP",
          "factor : T_ODD T_LP args_list T_RP",
          "factor : T_ORD T_LP args_list T_RP",
          "factor : T_PRED T_LP args_list T_RP",
          "factor : T_SQR T_LP args_list T_RP",
          "factor : T_SQRT T_LP args_list T_RP",
          "factor : T_SUCC T_LP args_list T_RP",
  };

//#line 714 "compiler.y"

  private scanner lex;
  private TreeNode savedTree;
  private char[] savedName;
  private int savedNum;
  private int yyline;
  private static ArrayList<String> errMsg = new ArrayList<String>();

  private int yylex() {
    int retVal = -1;
    try {
      retVal = lex.yylex();
      yyline=lex.getLineNumber();
    } catch (IOException e) {
      System.err.println("IO Error:" + e);
    }
    return retVal;
  }

  /* error reporting */
    /* constructor taking in File Input */
  public Parser (Reader r) {
    lex = new scanner (r, this);
  }
  public TreeNode parse(){
    yyparse();
    return this.savedTree;
  }
  static boolean interactive;
  public static void main (String [] args) throws IOException {
    Parser yyparser;
    String filePath = args[0];
    yyparser = new Parser(new FileReader(filePath));
    System.err.println("GSDPASCAL Parse Started");
    TreeNode syntaxTree = yyparser.parse();

    if(errMsg.size() != 0){
      for(String msg: errMsg){
        System.err.println(msg);
      }
    }
    System.err.println("GSDPASCAL Parse Ended");
    if(errMsg.size() == 0 && syntaxTree != null){
      System.out.println(syntaxTree);
      syntaxTree.printTree(syntaxTree, 0);
      CodeGenerator.getCodeGenerator().generate(syntaxTree);
      System.err.println("GSDPASCAL CodeGen Ended");
    }
  }

  /* error reporting */
  public void yyerror (String error) {
    System.err.println("Error : " + error + " at line " + lex.getLineNumber());
  }
  //#line 880 "Parser.java"
//###############################################################
// method: yylexdebug : check lexer state
//###############################################################
  void yylexdebug(int state,int ch)
  {
    String s=null;
    if (ch < 0) ch=0;
    if (ch <= YYMAXTOKEN) //check index bounds
      s = yyname[ch];    //now get it
    if (s==null)
      s = "illegal-symbol";
    debug("state "+state+", reading "+ch+" ("+s+")");
  }





  //The following are now global, to aid in error reporting
  int yyn;       //next next thing to do
  int yym;       //
  int yystate;   //current parsing state from state table
  String yys;    //current token string


  //###############################################################
// method: yyparse : parse input and execute indicated items
//###############################################################
  int yyparse()
  {
    boolean doaction;
    init_stacks();
    yynerrs = 0;
    yyerrflag = 0;
    yychar = -1;          //impossible char forces a read
    yystate=0;            //initial state
    state_push(yystate);  //save it
    val_push(yylval);     //save empty value
    while (true) //until parsing is done, either correctly, or w/error
    {
      doaction=true;
      if (yydebug) debug("loop");
      //#### NEXT ACTION (from reduction table)
      for (yyn=yydefred[yystate];yyn==0;yyn=yydefred[yystate])
      {
        if (yydebug) debug("yyn:"+yyn+"  state:"+yystate+"  yychar:"+yychar);
        if (yychar < 0)      //we want a char?
        {
          yychar = yylex();  //get next token
          if (yydebug) debug(" next yychar:"+yychar);
          //#### ERROR CHECK ####
          if (yychar < 0)    //it it didn't work/error
          {
            yychar = 0;      //change it to default string (no -1!)
            if (yydebug)
              yylexdebug(yystate,yychar);
          }
        }//yychar<0
        yyn = yysindex[yystate];  //get amount to shift by (shift index)
        if ((yyn != 0) && (yyn += yychar) >= 0 &&
                yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
        {
          if (yydebug)
            debug("state "+yystate+", shifting to state "+yytable[yyn]);
          //#### NEXT STATE ####
          yystate = yytable[yyn];//we are in a new state
          state_push(yystate);   //save it
          val_push(yylval);      //push our lval as the input for next rule
          yychar = -1;           //since we have 'eaten' a token, say we need another
          if (yyerrflag > 0)     //have we recovered an error?
            --yyerrflag;        //give ourselves credit
          doaction=false;        //but don't process yet
          break;   //quit the yyn=0 loop
        }

        yyn = yyrindex[yystate];  //reduce
        if ((yyn !=0 ) && (yyn += yychar) >= 0 &&
                yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
        {   //we reduced!
          if (yydebug) debug("reduce");
          yyn = yytable[yyn];
          doaction=true; //get ready to execute
          break;         //drop down to actions
        }
        else //ERROR RECOVERY
        {
          if (yyerrflag==0)
          {
            yyerror("syntax error");
            yynerrs++;
          }
          if (yyerrflag < 3) //low error count?
          {
            yyerrflag = 3;
            while (true)   //do until break
            {
              if (stateptr<0)   //check for under & overflow here
              {
                yyerror("stack underflow. aborting...");  //note lower case 's'
                return 1;
              }
              yyn = yysindex[state_peek(0)];
              if ((yyn != 0) && (yyn += YYERRCODE) >= 0 &&
                      yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
              {
                if (yydebug)
                  debug("state "+state_peek(0)+", error recovery shifting to state "+yytable[yyn]+" ");
                yystate = yytable[yyn];
                state_push(yystate);
                val_push(yylval);
                doaction=false;
                break;
              }
              else
              {
                if (yydebug)
                  debug("error recovery discarding state "+state_peek(0)+" ");
                if (stateptr<0)   //check for under & overflow here
                {
                  yyerror("Stack underflow. aborting...");  //capital 'S'
                  return 1;
                }
                state_pop();
                val_pop();
              }
            }
          }
          else            //discard this token
          {
            if (yychar == 0)
              return 1; //yyabort
            if (yydebug)
            {
              yys = null;
              if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
              if (yys == null) yys = "illegal-symbol";
              debug("state "+yystate+", error recovery discards token "+yychar+" ("+yys+")");
            }
            yychar = -1;  //read another
          }
        }//end error recovery
      }//yyn=0 loop
      if (!doaction)   //any reason not to proceed?
        continue;      //skip action
      yym = yylen[yyn];          //get count of terminals on rhs
      if (yydebug)
        debug("state "+yystate+", reducing "+yym+" by rule "+yyn+" ("+yyrule[yyn]+")");
      if (yym>0)                 //if count of rhs not 'nil'
        yyval = val_peek(yym-1); //get current semantic value
      yyval = dup_yyval(yyval); //duplicate yyval if ParserVal is used as semantic value
      switch(yyn)
      {
//########## USER-SUPPLIED ACTIONS ##########
        case 1:
//#line 34 "compiler.y"
        {   yyval.node = val_peek(1).node;
          yyval.node.setAttribute(val_peek(3).sval);
          savedTree = yyval.node;
        }
        break;
        case 2:
//#line 39 "compiler.y"
        {   yyval.node = val_peek(0).node;
          yyval.node.setAttribute(val_peek(2).sval);
          savedTree = yyval.node;
          errMsg.add("Error : error at line " + lex.getLineNumber() + ", lack of end dot");
        }
        break;
        case 3:
//#line 45 "compiler.y"
        {   yyval.node = val_peek(1).node;
          yyval.node.setAttribute(val_peek(2).sval);
          savedTree = yyval.node;
          errMsg.add("Error : error at line " + lex.getLineNumber() + ", lack of semicolon");
        }
        break;
        case 4:
//#line 51 "compiler.y"
        {   yyval.node = val_peek(0).node;
          yyval.node.setAttribute(val_peek(1).sval);
          savedTree = yyval.node;
          errMsg.add("Error : error at line " + lex.getLineNumber() + ", lack of semicolon and end dot");
        }
        break;
        case 5:
//#line 58 "compiler.y"
        {
          yyval.node =val_peek(1).node;
          yyval.node.setSibling(val_peek(0).node);
        }
        break;
        case 6:
//#line 63 "compiler.y"
        {
          yyval.node = new TreeNode(DeclarationKind.ROUTINEHEAD,yyline);
          yyval.node.addChild(val_peek(3).node);
          yyval.node.addChild(val_peek(2).node);
          yyval.node.addChild(val_peek(1).node);
          yyval.node.addChild(val_peek(0).node);
        }
        break;
        case 7:
//#line 71 "compiler.y"
        {   yyval.node= null;}
        break;
        case 8:
//#line 73 "compiler.y"
        {   TreeNode t=val_peek(1).node;
          if(t!=null){
            while(t.getSibling()!=null)
              t=t.getSibling();
            t.setSibling(val_peek(0).node);
            yyval.node=val_peek(1).node;
          }
          else
            yyval.node=val_peek(0).node;
        }
        break;
        case 9:
//#line 84 "compiler.y"
        {   TreeNode t=val_peek(1).node;
          if(t!=null){
            while(t.getSibling()!=null)
              t=t.getSibling();
            t.setSibling(val_peek(0).node);
            yyval.node=val_peek(1).node;
          }
          else
            yyval.node=val_peek(0).node;
        }
        break;
        case 10:
//#line 94 "compiler.y"
        {yyval.node=val_peek(0).node;}
        break;
        case 11:
//#line 95 "compiler.y"
        {yyval.node=val_peek(0).node;}
        break;
        case 12:
//#line 98 "compiler.y"
        {
          yyval.node=new TreeNode(DeclarationKind.FUNCTION,yyline);
          yyval.node.addChild(val_peek(3).node);
          yyval.node.addChild(val_peek(1).node);
        }
        break;
        case 13:
//#line 104 "compiler.y"
        {
          yyval.node=new TreeNode(DeclarationKind.FUNCTION,yyline);
          yyval.node.addChild(val_peek(2).node);
          yyval.node.addChild(val_peek(0).node);
          errMsg.add("Error : error at line " + lex.getLineNumber() + ", lack of semicolon");
        }
        break;
        case 14:
//#line 111 "compiler.y"
        {
          yyval.node=new TreeNode(DeclarationKind.FUNCTION,yyline);
          yyval.node.addChild(val_peek(2).node);
          yyval.node.addChild(val_peek(1).node);
          errMsg.add("Error : error at line " + lex.getLineNumber() + ", lack of semicolon");
        }
        break;
        case 15:
//#line 118 "compiler.y"
        {
          yyval.node=new TreeNode(DeclarationKind.FUNCTION,yyline);
          yyval.node.addChild(val_peek(1).node);
          yyval.node.addChild(val_peek(0).node);
          errMsg.add("Error : error at line " + lex.getLineNumber() + ", lack of semicolon");
        }
        break;
        case 16:
//#line 126 "compiler.y"
        {
          yyval.node=new TreeNode(DeclarationKind.FUNCTIONHEAD,yyline);
          yyval.node.setAttribute(val_peek(3).sval);
          yyval.node.addChild(val_peek(2).node);
          yyval.node.addChild(val_peek(0).node);
        }
        break;
        case 17:
//#line 134 "compiler.y"
        {yyval.node=null;}
        break;
        case 18:
//#line 136 "compiler.y"
        {yyval.node=val_peek(1).node;}
        break;
        case 19:
//#line 139 "compiler.y"
        {   TreeNode t=val_peek(2).node;
          if(t!=null){
            while(t.getSibling()!=null)
              t=t.getSibling();
            t.setSibling(val_peek(0).node);
            yyval.node=val_peek(2).node;
          }
          else
            yyval.node=val_peek(0).node;
        }
        break;
        case 20:
//#line 150 "compiler.y"
        {   yyval.node=val_peek(0).node; }
        break;
        case 21:
//#line 153 "compiler.y"
        {
          yyval.node=new TreeNode(DeclarationKind.VAR_PARA,yyline);
          yyval.node.addChild(val_peek(2).node);
          yyval.node.addChild(val_peek(0).node);
        }
        break;
        case 22:
//#line 159 "compiler.y"
        {
          yyval.node=new TreeNode(DeclarationKind.VAL_PARA,yyline);
          yyval.node.addChild(val_peek(2).node);
          yyval.node.addChild(val_peek(0).node);
        }
        break;
        case 23:
//#line 166 "compiler.y"
        {
          yyval.node=new TreeNode(DeclarationKind.PROCEDURE,yyline);
          yyval.node.addChild(val_peek(3).node);
          yyval.node.addChild(val_peek(1).node);
        }
        break;
        case 24:
//#line 173 "compiler.y"
        {
          yyval.node=new TreeNode(DeclarationKind.PROCEDUREHEAD,yyline);
          yyval.node.setAttribute(val_peek(1).sval);
          yyval.node.addChild(val_peek(0).node);
        }
        break;
        case 25:
//#line 180 "compiler.y"
        {   yyval.node = null;}
        break;
        case 26:
//#line 182 "compiler.y"
        {   yyval.node=val_peek(0).node;}
        break;
        case 27:
//#line 185 "compiler.y"
        {   TreeNode t = val_peek(1).node;
          if(t!=null){
            while(t.getSibling()!=null)
              t=t.getSibling();
            t.setSibling(val_peek(0).node);
            yyval.node=val_peek(1).node;
          }
          else
            yyval.node=val_peek(0).node;
        }
        break;
        case 28:
//#line 195 "compiler.y"
        {yyval.node=val_peek(0).node;}
        break;
        case 29:
//#line 198 "compiler.y"
        {   yyval.node=new TreeNode(DeclarationKind.VAR,yyline);
          yyval.node.addChild(val_peek(3).node);
          yyval.node.addChild(val_peek(1).node);
        }
        break;
        case 30:
//#line 203 "compiler.y"
        {   yyval.node=new TreeNode(DeclarationKind.VAR,yyline);
          yyval.node.addChild(val_peek(2).node);
          yyval.node.addChild(val_peek(0).node);
          errMsg.add("Error : error at line " + lex.getLineNumber() + ", lack of semicolon");
        }
        break;
        case 31:
//#line 210 "compiler.y"
        {   yyval.node = null; }
        break;
        case 32:
//#line 212 "compiler.y"
        {   yyval.node=val_peek(0).node; }
        break;
        case 33:
//#line 215 "compiler.y"
        {
          TreeNode t = val_peek(1).node;
          if(t!=null){
            while(t.getSibling()!=null)
              t=t.getSibling();
            t.setSibling(val_peek(0).node);
            yyval.node=val_peek(1).node;
          }
          else
            yyval.node=val_peek(0).node;
        }
        break;
        case 34:
//#line 228 "compiler.y"
        {   yyval.node=val_peek(0).node; }
        break;
        case 35:
//#line 231 "compiler.y"
        {
          yyval.node=new TreeNode(DeclarationKind.CONST,yyline);
          yyval.node.setAttribute(val_peek(3).node.getAttribute());
          yyval.node.addChild(val_peek(1).node);
          yyval.node.setExpType(val_peek(1).node.getExpType());
        }
        break;
        case 36:
//#line 238 "compiler.y"
        {
          yyval.node=new TreeNode(DeclarationKind.CONST,yyline);
          yyval.node.setAttribute(val_peek(2).node.getAttribute());
          yyval.node.addChild(val_peek(0).node);
          yyval.node.setExpType(val_peek(0).node.getExpType());
          errMsg.add("Error : error at line " + lex.getLineNumber() + ", lack of semicolon");
        }
        break;
        case 37:
//#line 247 "compiler.y"
        {
          yyval.node =new TreeNode(ExpressionKind.CONST,yyline);
          yyval.node.setExpType(ExpressionType.INT);
          yyval.node.setAttribute(val_peek(0).ival);
        }
        break;
        case 38:
//#line 253 "compiler.y"
        {
          yyval.node = new TreeNode(ExpressionKind.CONST,yyline);
          yyval.node.setExpType(ExpressionType.REAL);
          yyval.node.setAttribute(val_peek(0).dval);
        }
        break;
        case 39:
//#line 259 "compiler.y"
        {
          yyval.node = new TreeNode(ExpressionKind.CONST,yyline);
          yyval.node.setExpType(ExpressionType.CHAR);
          yyval.node.setAttribute(val_peek(0).sval.toCharArray());
        }
        break;
        case 40:
//#line 265 "compiler.y"
        {
          yyval.node = new TreeNode(ExpressionKind.CONST,yyline);
          yyval.node.setExpType(ExpressionType.STRING);
          yyval.node.setAttribute(val_peek(0).sval);
        }
        break;
        case 41:
//#line 271 "compiler.y"
        {
          yyval.node=new TreeNode(ExpressionKind.CONST,yyline);
          yyval.node.setExpType(ExpressionType.BOOL);
          yyval.node.setAttribute(1);
        }
        break;
        case 42:
//#line 277 "compiler.y"
        {
          yyval.node=new TreeNode(ExpressionKind.CONST,yyline);
          yyval.node.setExpType(ExpressionType.BOOL);
          yyval.node.setAttribute(0);
        }
        break;
        case 43:
//#line 283 "compiler.y"
        {
          yyval.node=new TreeNode(ExpressionKind.CONST,yyline);
          yyval.node.setExpType(ExpressionType.INT);
          yyval.node.setAttribute(2147483647);
        }
        break;
        case 44:
//#line 290 "compiler.y"
        {   yyval.node=null;}
        break;
        case 45:
//#line 292 "compiler.y"
        {   yyval.node=val_peek(0).node;}
        break;
        case 46:
//#line 295 "compiler.y"
        {
          TreeNode t=val_peek(1).node;
          if(t!=null){
            while(t.getSibling()!=null)
              t=t.getSibling();
            t.setSibling(val_peek(0).node);
            yyval.node=val_peek(1).node;
          }
          else
            yyval.node=val_peek(0).node;
        }
        break;
        case 47:
//#line 307 "compiler.y"
        {   yyval.node=val_peek(0).node;}
        break;
        case 48:
//#line 310 "compiler.y"
        {   yyval.node=new TreeNode(DeclarationKind.TYPE,yyline);
          yyval.node.addChild(val_peek(3).node);
          yyval.node.addChild(val_peek(1).node);
        }
        break;
        case 49:
//#line 315 "compiler.y"
        {   yyval.node=new TreeNode(DeclarationKind.TYPE,yyline);
          yyval.node.addChild(val_peek(2).node);
          yyval.node.addChild(val_peek(0).node);
          errMsg.add("Error : error at line " + lex.getLineNumber() + ", lack of semicolon");
        }
        break;
        case 50:
//#line 321 "compiler.y"
        {yyval.node=val_peek(0).node;}
        break;
        case 51:
//#line 322 "compiler.y"
        {yyval.node=val_peek(0).node;}
        break;
        case 52:
//#line 323 "compiler.y"
        {yyval.node=val_peek(0).node;}
        break;
        case 53:
//#line 326 "compiler.y"
        {   yyval.node=val_peek(1).node; }
        break;
        case 54:
//#line 329 "compiler.y"
        {
          TreeNode t=val_peek(1).node;
          if(t!=null){
            while(t.getSibling()!=null)
              t=t.getSibling();
            t.setSibling(val_peek(0).node);
            yyval.node=val_peek(1).node;
          }
          else
            yyval.node=val_peek(0).node;
        }
        break;
        case 55:
//#line 340 "compiler.y"
        {yyval.node=val_peek(0).node;}
        break;
        case 56:
//#line 343 "compiler.y"
        {
          yyval.node=new TreeNode(TypeKind.RECORD,yyline);
          yyval.node.addChild(val_peek(3).node);
          yyval.node.addChild(val_peek(1).node);
        }
        break;
        case 57:
//#line 349 "compiler.y"
        {
          yyval.node=new TreeNode(TypeKind.RECORD,yyline);
          yyval.node.addChild(val_peek(2).node);
          yyval.node.addChild(val_peek(0).node);
          errMsg.add("Error : error at line " + lex.getLineNumber() + ", lack of semicolon");
        }
        break;
        case 58:
//#line 357 "compiler.y"
        {
          yyval.node=new TreeNode(TypeKind.ARRAY,yyline);
          yyval.node.addChild(val_peek(3).node);
          yyval.node.addChild(val_peek(0).node);
          yyval.node.setExpType(ExpressionType.ARRAY);
        }
        break;
        case 59:
//#line 365 "compiler.y"
        {
          yyval.node=new TreeNode(TypeKind.SIMPLE_ID,yyline);
          yyval.node.setAttribute(val_peek(0).node.getAttribute());
                            /*free($1);*/
        }
        break;
        case 60:
//#line 371 "compiler.y"
        {   yyval.node=new TreeNode(TypeKind.SIMPLE_ENUM,yyline);
          yyval.node.addChild(val_peek(1).node);
          yyval.node.setExpType(ExpressionType.SIMPLE_ENUM);
        }
        break;
        case 61:
//#line 376 "compiler.y"
        {   yyval.node=new TreeNode(TypeKind.SIMPLE_LIMIT,yyline);
          yyval.node.addChild(val_peek(2).node);
          yyval.node.addChild(val_peek(0).node);
          yyval.node.setExpType(ExpressionType.SIMPLE_LIMIT);
        }
        break;
        case 62:
//#line 382 "compiler.y"
        {
          yyval.node=new TreeNode(TypeKind.SIMPLE_LIMIT,yyline);
          yyval.node.addChild(val_peek(2).node);
          yyval.node.getChildren().get(0).setAttribute(Integer.parseInt(String.valueOf(yyval.node.getChildren().get(0).getAttribute()))*(-1));
          yyval.node.addChild(val_peek(0).node);
          yyval.node.setExpType(ExpressionType.SIMPLE_LIMIT);
        }
        break;
        case 63:
//#line 390 "compiler.y"
        {   yyval.node=new TreeNode(TypeKind.SIMPLE_LIMIT,yyline);
          yyval.node.addChild(val_peek(3).node);
          yyval.node.getChildren().get(0).setAttribute(Integer.parseInt(String.valueOf(yyval.node.getChildren().get(0).getAttribute()))*(-1));
          yyval.node.addChild(val_peek(0).node);
          yyval.node.getChildren().get(1).setAttribute(Integer.parseInt(String.valueOf(yyval.node.getChildren().get(1).getAttribute()))*(-1));
          yyval.node.setExpType(ExpressionType.SIMPLE_LIMIT);
        }
        break;
        case 64:
//#line 398 "compiler.y"
        {
          yyval.node=new TreeNode(TypeKind.SIMPLE_LIMIT,yyline);
          yyval.node.addChild(val_peek(2).node);
          yyval.node.addChild(val_peek(0).node);
          yyval.node.setExpType(ExpressionType.SIMPLE_LIMIT);
        }
        break;
        case 65:
//#line 405 "compiler.y"
        {   yyval.node=new TreeNode(TypeKind.SIMPLE_SYS,yyline);
          yyval.node.setExpType(ExpressionType.INT);
        }
        break;
        case 66:
//#line 409 "compiler.y"
        {   yyval.node=new TreeNode(TypeKind.SIMPLE_SYS,yyline);
          yyval.node.setExpType(ExpressionType.BOOL);
        }
        break;
        case 67:
//#line 413 "compiler.y"
        {   yyval.node=new TreeNode(TypeKind.SIMPLE_SYS,yyline);
          yyval.node.setExpType(ExpressionType.REAL);
        }
        break;
        case 68:
//#line 417 "compiler.y"
        {   yyval.node=new TreeNode(TypeKind.SIMPLE_SYS,yyline);
          yyval.node.setExpType(ExpressionType.CHAR);
        }
        break;
        case 69:
//#line 422 "compiler.y"
        {
          TreeNode t=val_peek(2).node;
          if(t!=null){
            while(t.getSibling()!=null)
              t=t.getSibling();
            t.setSibling(val_peek(0).node);
            yyval.node=val_peek(2).node;
          }
          else
            yyval.node=val_peek(0).node;
        }
        break;
        case 70:
//#line 433 "compiler.y"
        {   yyval.node=val_peek(0).node; }
        break;
        case 71:
//#line 436 "compiler.y"
        {   yyval.node=new TreeNode(ExpressionKind.ID,yyline);
          yyval.node.setAttribute(val_peek(0).sval);
        }
        break;
        case 72:
//#line 439 "compiler.y"
        {yyval.node=val_peek(0).node;}
        break;
        case 73:
//#line 440 "compiler.y"
        {yyval.node=val_peek(1).node;}
        break;
        case 74:
//#line 441 "compiler.y"
        {yyval.node=val_peek(0).node; errMsg.add("Error : error at line " + lex.getLineNumber() + ", lack of end");}
        break;
        case 75:
//#line 443 "compiler.y"
        {yyval.node=null;}
        break;
        case 76:
//#line 445 "compiler.y"
        {
          TreeNode t=val_peek(2).node;
          if(t!=null){
            while(t.getSibling()!=null)
              t=t.getSibling();
            t.setSibling(val_peek(1).node);
            yyval.node=val_peek(2).node;
          }
          else
            yyval.node=val_peek(1).node;
        }
        break;
        case 77:
//#line 457 "compiler.y"
        {
          TreeNode t=val_peek(1).node;
          if(t!=null){
            while(t.getSibling()!=null)
              t=t.getSibling();
            t.setSibling(val_peek(0).node);
            yyval.node=val_peek(1).node;
          }
          else
            yyval.node=val_peek(0).node;
          errMsg.add("Error : error at line " + lex.getLineNumber() + ", lack of semicolon");
        }
        break;
        case 78:
//#line 471 "compiler.y"
        {
          yyval.node=new TreeNode(StatementKind.LABEL,yyline);
          yyval.node.setAttribute(val_peek(2).ival);
          yyval.node.addChild(val_peek(0).node);
        }
        break;
        case 79:
//#line 477 "compiler.y"
        {   yyval.node=val_peek(0).node;}
        break;
        case 80:
//#line 479 "compiler.y"
        {yyval.node=val_peek(0).node;}
        break;
        case 81:
//#line 480 "compiler.y"
        {yyval.node=val_peek(0).node;}
        break;
        case 82:
//#line 481 "compiler.y"
        {yyval.node=val_peek(0).node;}
        break;
        case 83:
//#line 482 "compiler.y"
        {yyval.node=val_peek(0).node;}
        break;
        case 84:
//#line 483 "compiler.y"
        {yyval.node=val_peek(0).node;}
        break;
        case 85:
//#line 484 "compiler.y"
        {yyval.node=val_peek(0).node;}
        break;
        case 86:
//#line 485 "compiler.y"
        {yyval.node=val_peek(0).node;}
        break;
        case 87:
//#line 486 "compiler.y"
        {yyval.node=val_peek(0).node;}
        break;
        case 88:
//#line 487 "compiler.y"
        {yyval.node=val_peek(0).node;}
        break;
        case 89:
//#line 489 "compiler.y"
        {   yyval.node=new TreeNode(StatementKind.ASSIGN,yyline);
          yyval.node.addChild(val_peek(2).node);
          yyval.node.addChild(val_peek(0).node);
          yyval.node.setAttribute(OperationKind.ID);
        }
        break;
        case 90:
//#line 495 "compiler.y"
        {   yyval.node=new TreeNode(StatementKind.ASSIGN,yyline);
          yyval.node.addChild(val_peek(5).node);
          (yyval.node.getChildren().get(0)).addChild(val_peek(3).node);
          yyval.node.addChild(val_peek(0).node);
          yyval.node.setAttribute(OperationKind.ARRAY);
        }
        break;
        case 91:
//#line 503 "compiler.y"
        {   yyval.node=new TreeNode(StatementKind.ASSIGN,yyline);
          yyval.node.addChild(val_peek(4).node);
          (yyval.node.getChildren().get(0)).addChild(val_peek(2).node);
          yyval.node.addChild(val_peek(0).node);
          yyval.node.setAttribute(OperationKind.RECORD);
        }
        break;
        case 92:
//#line 511 "compiler.y"
        {   yyval.node=new TreeNode(StatementKind.GOTO,yyline);
          yyval.node.setAttribute(val_peek(0).ival);
        }
        break;
        case 93:
//#line 516 "compiler.y"
        {   yyval.node=new TreeNode(StatementKind.IF,yyline);
          yyval.node.addChild(val_peek(3).node);
          yyval.node.addChild(val_peek(1).node);
          yyval.node.addChild(val_peek(0).node);
        }
        break;
        case 94:
//#line 522 "compiler.y"
        {   yyval.node=new TreeNode(StatementKind.IF,yyline);
          yyval.node.addChild(val_peek(2).node);
          yyval.node.addChild(val_peek(1).node);
          yyval.node.addChild(val_peek(0).node);
          errMsg.add("Error : error at line " + lex.getLineNumber() + ", lack of then");
        }
        break;
        case 95:
//#line 529 "compiler.y"
        {yyval.node=null;}
        break;
        case 96:
//#line 530 "compiler.y"
        {yyval.node=val_peek(0).node;}
        break;
        case 97:
//#line 533 "compiler.y"
        {
          yyval.node=new TreeNode(StatementKind.REPEAT,yyline);
          yyval.node.addChild(val_peek(2).node);
          yyval.node.addChild(val_peek(0).node);
        }
        break;
        case 99:
//#line 541 "compiler.y"
        {   yyval.node=new TreeNode(StatementKind.WHILE,yyline);
          yyval.node.addChild(val_peek(2).node);
          yyval.node.addChild(val_peek(0).node);
        }
        break;
        case 100:
//#line 546 "compiler.y"
        {   yyval.node=new TreeNode(StatementKind.CASE,yyline);
          yyval.node.addChild(val_peek(3).node);
          yyval.node.addChild(val_peek(1).node);
        }
        break;
        case 101:
//#line 551 "compiler.y"
        {   TreeNode t=val_peek(1).node;
          if(t!=null){
            while(t.getSibling()!=null)
              t=t.getSibling();
            t.setSibling(val_peek(0).node);
            yyval.node=val_peek(1).node;
          }
          else
            yyval.node=val_peek(0).node;
        }
        break;
        case 102:
//#line 561 "compiler.y"
        {yyval.node=val_peek(0).node;}
        break;
        case 103:
//#line 563 "compiler.y"
        {
          yyval.node=new TreeNode(ExpressionKind.CASE,yyline);
          yyval.node.addChild(val_peek(3).node);
          yyval.node.addChild(val_peek(1).node);
        }
        break;
        case 104:
//#line 569 "compiler.y"
        {
          yyval.node=new TreeNode(ExpressionKind.CASE,yyline);
          yyval.node.addChild(val_peek(3).node);
          yyval.node.addChild(val_peek(1).node);
        }
        break;
        case 105:
//#line 575 "compiler.y"
        {
          yyval.node=new TreeNode(StatementKind.FOR,yyline);
          yyval.node.addChild(val_peek(6).node);
          yyval.node.addChild(val_peek(4).node);
          yyval.node.addChild(val_peek(2).node);
          yyval.node.addChild(val_peek(0).node);
          yyval.node.setAttribute(OperationKind.TO);
        }
        break;
        case 106:
//#line 584 "compiler.y"
        {
          yyval.node=new TreeNode(StatementKind.FOR,yyline);
          yyval.node.addChild(val_peek(6).node);
          yyval.node.addChild(val_peek(4).node);
          yyval.node.addChild(val_peek(2).node);
          yyval.node.addChild(val_peek(0).node);
          yyval.node.setAttribute(OperationKind.DOWNTO);
        }
        break;
        case 107:
//#line 593 "compiler.y"
        {   yyval.node=new TreeNode(StatementKind.PROC_ID,yyline);
          yyval.node.setAttribute(val_peek(0).node.getAttribute());
        }
        break;
        case 108:
//#line 597 "compiler.y"
        {   yyval.node=new TreeNode(StatementKind.PROC_ID,yyline);
          yyval.node.setAttribute(val_peek(3).node.getAttribute());
          yyval.node.addChild(val_peek(1).node);
        }
        break;
        case 109:
//#line 602 "compiler.y"
        {
          yyval.node=new TreeNode(StatementKind.PROC_SYS,yyline);
          yyval.node.setAttribute(OperationKind.READ);
          yyval.node.addChild(val_peek(1).node);
        }
        break;
        case 110:
//#line 608 "compiler.y"
        {   yyval.node=new TreeNode(StatementKind.PROC_SYS,yyline);
          yyval.node.setAttribute(OperationKind.WRITE);
          yyval.node.addChild(val_peek(1).node);
        }
        break;
        case 111:
//#line 613 "compiler.y"
        {   yyval.node=new TreeNode(StatementKind.PROC_SYS,yyline);
          yyval.node.setAttribute(OperationKind.WRITELN);
        }
        break;
        case 112:
//#line 617 "compiler.y"
        {   yyval.node=new TreeNode(StatementKind.PROC_SYS,yyline);
          yyval.node.setAttribute(OperationKind.WRITELN);
          yyval.node.addChild(val_peek(1).node);
        }
        break;
        case 113:
//#line 622 "compiler.y"
        {   TreeNode t=val_peek(2).node;
          if(t!=null){
            while(t.getSibling()!=null)
              t=t.getSibling();
            t.setSibling(val_peek(0).node);
            yyval.node=val_peek(2).node;
          }
          else
            yyval.node=val_peek(0).node;
        }
        break;
        case 114:
//#line 632 "compiler.y"
        {yyval.node=val_peek(0).node;}
        break;
        case 115:
//#line 634 "compiler.y"
        {   yyval.node=new TreeNode(val_peek(2).node,val_peek(0).node,OperationKind.GE,yyline); }
        break;
        case 116:
//#line 635 "compiler.y"
        {   yyval.node=new TreeNode(val_peek(2).node,val_peek(0).node,OperationKind.GT,yyline); }
        break;
        case 117:
//#line 636 "compiler.y"
        {   yyval.node=new TreeNode(val_peek(2).node,val_peek(0).node,OperationKind.LE,yyline); }
        break;
        case 118:
//#line 637 "compiler.y"
        {   yyval.node=new TreeNode(val_peek(2).node,val_peek(0).node,OperationKind.LT,yyline); }
        break;
        case 119:
//#line 638 "compiler.y"
        {   yyval.node=new TreeNode(val_peek(2).node,val_peek(0).node,OperationKind.EQUAL,yyline); }
        break;
        case 120:
//#line 639 "compiler.y"
        {  yyval.node=new TreeNode(val_peek(2).node,val_peek(0).node,OperationKind.UNEQUAL,yyline); }
        break;
        case 121:
//#line 640 "compiler.y"
        {   yyval.node=val_peek(0).node;}
        break;
        case 122:
//#line 642 "compiler.y"
        {   yyval.node=new TreeNode(val_peek(2).node,val_peek(0).node,OperationKind.PLUS,yyline); }
        break;
        case 123:
//#line 643 "compiler.y"
        {  yyval.node=new TreeNode(val_peek(2).node,val_peek(0).node,OperationKind.MINUS,yyline); }
        break;
        case 124:
//#line 644 "compiler.y"
        {     yyval.node=new TreeNode(val_peek(2).node,val_peek(0).node,OperationKind.OR,yyline); }
        break;
        case 125:
//#line 645 "compiler.y"
        {   yyval.node=val_peek(0).node;}
        break;
        case 126:
//#line 647 "compiler.y"
        {   yyval.node=new TreeNode(val_peek(2).node,val_peek(0).node,OperationKind.MUL,yyline); }
        break;
        case 127:
//#line 648 "compiler.y"
        {   yyval.node=new TreeNode(val_peek(2).node,val_peek(0).node,OperationKind.DIV,yyline); }
        break;
        case 128:
//#line 649 "compiler.y"
        {   yyval.node=new TreeNode(val_peek(2).node,val_peek(0).node,OperationKind.MOD,yyline); }
        break;
        case 129:
//#line 650 "compiler.y"
        {   yyval.node=new TreeNode(val_peek(2).node,val_peek(0).node,OperationKind.AND,yyline); }
        break;
        case 130:
//#line 651 "compiler.y"
        {yyval.node=val_peek(0).node;}
        break;
        case 131:
//#line 654 "compiler.y"
        {yyval.node=val_peek(0).node;}
        break;
        case 132:
//#line 656 "compiler.y"
        {
          yyval.node=new TreeNode(ExpressionKind.FUNC_ID,yyline);
          yyval.node.setAttribute(val_peek(3).node.getAttribute());
          yyval.node.addChild(val_peek(1).node);
        }
        break;
        case 133:
//#line 661 "compiler.y"
        {yyval.node=val_peek(0).node;}
        break;
        case 134:
//#line 662 "compiler.y"
        {yyval.node=val_peek(1).node;}
        break;
        case 135:
//#line 664 "compiler.y"
        {
          yyval.node=new TreeNode(val_peek(0).node,null,OperationKind.NOT,yyline);
        }
        break;
        case 136:
//#line 668 "compiler.y"
        {   yyval.node=new TreeNode(val_peek(0).node, null, OperationKind.MINUS, yyline);
        }
        break;
        case 137:
//#line 671 "compiler.y"
        {   yyval.node=val_peek(3).node;
          yyval.node.addChild(val_peek(1).node);
          yyval.node.setExpType(ExpressionType.ARRAY);
        }
        break;
        case 138:
//#line 676 "compiler.y"
        {   yyval.node=val_peek(2).node;
          yyval.node.addChild(val_peek(0).node);
          yyval.node.setExpType(ExpressionType.RECORD);
        }
        break;
        case 139:
//#line 681 "compiler.y"
        {
          yyval.node=new TreeNode(OperationKind.ABS, val_peek(1).node,yyline);
        }
        break;
        case 140:
//#line 685 "compiler.y"
        {
          yyval.node=new TreeNode(OperationKind.CHR, val_peek(1).node,yyline);
        }
        break;
        case 141:
//#line 689 "compiler.y"
        {
          yyval.node=new TreeNode(OperationKind.ODD, val_peek(1).node,yyline);
        }
        break;
        case 142:
//#line 693 "compiler.y"
        {

          yyval.node=new TreeNode(OperationKind.ORD, val_peek(1).node,yyline);
        }
        break;
        case 143:
//#line 698 "compiler.y"
        {
          yyval.node=new TreeNode(OperationKind.PRED, val_peek(1).node,yyline);
        }
        break;
        case 144:
//#line 702 "compiler.y"
        {
          yyval.node=new TreeNode(OperationKind.SQR, val_peek(1).node,yyline);
        }
        break;
        case 145:
//#line 706 "compiler.y"
        {
          yyval.node=new TreeNode(OperationKind.SQRT, val_peek(1).node,yyline);
        }
        break;
        case 146:
//#line 710 "compiler.y"
        {   yyval.node=new TreeNode(OperationKind.SUCC, val_peek(1).node,yyline);
        }
        break;
//#line 2000 "Parser.java"
//########## END OF USER-SUPPLIED ACTIONS ##########
      }//switch
      //#### Now let's reduce... ####
      if (yydebug) debug("reduce");
      state_drop(yym);             //we just reduced yylen states
      yystate = state_peek(0);     //get new state
      val_drop(yym);               //corresponding value drop
      yym = yylhs[yyn];            //select next TERMINAL(on lhs)
      if (yystate == 0 && yym == 0)//done? 'rest' state and at first TERMINAL
      {
        if (yydebug) debug("After reduction, shifting from state 0 to state "+YYFINAL+"");
        yystate = YYFINAL;         //explicitly say we're done
        state_push(YYFINAL);       //and save it
        val_push(yyval);           //also save the semantic value of parsing
        if (yychar < 0)            //we want another character?
        {
          yychar = yylex();        //get next character
          if (yychar<0) yychar=0;  //clean, if necessary
          if (yydebug)
            yylexdebug(yystate,yychar);
        }
        if (yychar == 0)          //Good exit (if lex returns 0 ;-)
          break;                 //quit the loop--all DONE
      }//if yystate
      else                        //else not done yet
      {                         //get next state and push, for next yydefred[]
        yyn = yygindex[yym];      //find out where to go
        if ((yyn != 0) && (yyn += yystate) >= 0 &&
                yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
          yystate = yytable[yyn]; //get new state
        else
          yystate = yydgoto[yym]; //else go to new defred
        if (yydebug) debug("after reduction, shifting from state "+state_peek(0)+" to state "+yystate+"");
        state_push(yystate);     //going again, so push state & val...
        val_push(yyval);         //for next action
      }
    }//main loop
    return 0;//yyaccept!!
  }
//## end of method parse() ######################################



//## run() --- for Thread #######################################
  /**
   * A default run method, used for operating this parser
   * object in the background.  It is intended for extending Thread
   * or implementing Runnable.  Turn off with -Jnorun .
   */
  public void run()
  {
    yyparse();
  }
//## end of method run() ########################################



//## Constructors ###############################################
  /**
   * Default constructor.  Turn off with -Jnoconstruct .

   */
  public Parser()
  {
    //nothing to do
  }


  /**
   * Create a parser, setting the debug to true or false.
   * @param debugMe true for debugging, false for no debug.
   */
  public Parser(boolean debugMe)
  {
    yydebug=debugMe;
  }
//###############################################################



}
//################### END OF CLASS ##############################
